
var Livefyre;(function () { if (!Livefyre || !Livefyre.requirejs) {
if (!Livefyre) { Livefyre = {}; } else { require = Livefyre; }
/**
 * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

Livefyre.requirejs = requirejs;Livefyre.require = require;Livefyre.define = define;
}
}());
Livefyre.define("almond", function(){});

Livefyre.define('event-emitter',[],function() {

    var slice = Array.prototype.slice;

    /**
     * Defines the base class for all event emitting objects to extend.
     * @exports streamhub-sdk/event-emitter
     * @constructor
     */
    var EventEmitter = function() {
        this._listeners = {};
    };


    EventEmitter.listenerCount = function (emitter, eventName) {
        var listeners = emitter._listeners[eventName];
        if ( ! listeners) {
            return 0;
        }
        return listeners.length;
    };


    /**
     * Binds a listener function to an event name.
     * @param name {string} The event name to bind to.
     * @param fn {function} The callback function to call whenever the event is emitted.
     * @returns {EventEmitter} Returns 'this' for chaining
     */
    EventEmitter.prototype.on = function(name, fn) {
        this._listeners[name] = this._listeners[name] || [];
        this._listeners[name].push(fn);
        return this;
    };
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;


    EventEmitter.prototype.once = function (name, fn) {
        function doAndRemoveListener () {
            this.removeListener(name, doAndRemoveListener);
            fn.apply(this, arguments);
        }
        // Store original listener
        doAndRemoveListener.listener = fn;
        return this.on(name, doAndRemoveListener);
    };


    /**
     * Removes a bound listener from the named event.
     * @param name {string} The name of the event to remove this listener from.
     * @param fn {function} The original callback function to remove.
     */
    EventEmitter.prototype.removeListener = function(name, fn) {
        if (fn && this._listeners[name]) {
            this._listeners[name].splice(this._listeners[name].indexOf(fn), 1);
        }
    };

    /**
     * Emits an event from the object this is called on. Iterates through bound
     * listeners and passes through the arguments emit was called with.
     * @param name {string} The name of the event to emit.
     * @param {...Object} Optional arguments to pass to each listener's callback.
     */
    EventEmitter.prototype.emit = function(name) {
        var listeners = this._listeners[name] || [],
            args = slice.call(arguments, 1),
            err;

        // Copy listeners in case executing them mutates the array
        // e.g. .once() listeners remove themselves
        if (listeners.length) {
            listeners = listeners.slice();
        }
        
        // Throw on error event if there are no listeners
        if (name === 'error' && ! listeners.length) {
            err = args[0];
            if (err instanceof Error) {
                throw err;
            } else {
                throw TypeError('Uncaught, unspecified "error" event');
            }
        }

        for (var i=0, numListeners=listeners.length; i < numListeners; i++) {
            try {
                listeners[i].apply(this, args); 
            } catch(err) {
                this.emit('error', err);
            }
        }
    };

    return EventEmitter;
});

Livefyre.define('inherits',[], function () {


    /**
     * sub should prototypally inherit from base
     * @param sub {function} Subclass constructor
     * @param base {function} Base class constructor
     */
    function inherits (sub, base) {
        var Fn = function(){};
        Fn.prototype = base.prototype;
        sub.prototype = new Fn();
        sub.prototype.constructor = sub;
    }


    /**
     * sub should parasitically inherit from base
     * that is, we should pluck values from base.prototype onto sub.prototype
     */
    inherits.parasitically = function (sub, base) {
        var baseKeys = inherits.keys(base.prototype),
            baseKeysLength = baseKeys.length,
            methodName;
        for (var i=0; i < baseKeysLength; i++) {
            methodName = baseKeys[i];
            if ( ! sub.prototype[methodName]) {
                sub.prototype[methodName] = base.prototype[methodName];
            }
        }
    };


    /**
     * Object.keys shim
     */
    inherits.keys = Object.keys || (function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{toString:null}.propertyIsEnumerable("toString"),
            DontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            DontEnumsLength = DontEnums.length;

        return function (o) {
            if (typeof o != "object" && typeof o != "function" || o === null)
                throw new TypeError("Object.keys called on a non-object");

            var result = [];
            for (var name in o) {
                if (hasOwnProperty.call(o, name))
                    result.push(name);
            }

            if (hasDontEnumBug) {
                for (var i = 0; i < DontEnumsLength; i++) {
                    if (hasOwnProperty.call(o, DontEnums[i]))
                        result.push(DontEnums[i]);
                }
            }

            return result;
        };
    })();

    return inherits;
});
Livefyre.define('auth-delegates/util/jsonp',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview Very small jsonp implementation.
 */

function req(url, callback) {
    var rand = '_lfcallback_' + (+new Date()),
        script = document.createElement('script'),
        sep = url.indexOf('?') > 0 ? '&' : '?';

    function clean() {
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
        delete window[rand];
    }

    window[rand] = function(data) {
        clean();
        callback(null, data);
    };

    script.type = 'text/javascript';
    script.async = true;

    script.onerror = function() {
        clean();
        callback('error');
    };

    script.src = url + sep + 'callback=' + rand;
    document.getElementsByTagName('head')[0].appendChild(script);
}

module.exports = {
    req: req
};

});

Livefyre.define('auth-delegates/util/storage',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview Storage helpers: if window.localStroage is unavailable, then defaults to cookie
 * based storage. Automatically handles expiration and JSON serialization for both types of storage.
 */

var STORAGE_AVAILABLE_KEY = '__lfstorage__',
    canUseLocalStorage = (function() {
        try {
            // Weird cases where accessing localStorage global will throw an error.
            var storage = localStorage || null;
            // setItem will throw an exception if we cannot access WebStorage (e.g.,
            // Safari in private mode).
            storage.setItem(STORAGE_AVAILABLE_KEY, '1');
            storage.removeItem(STORAGE_AVAILABLE_KEY);
            return true;
        } catch (e) {
            return false;
        }
    })();

/**
 * LocalStorage storage object.
 * Attempts to rectify the many ways that browsers can interpret the localStorage object with heavy
 * use of try-catch blocks.
 */
var html5Storage = {
    /**
     * @param {string} key
     * @param {*} value
     * @param {number=} opt_expiration In UTC time
     */
    set: function(key, value, opt_expiration) {
        var valueObj = {
            value: value,
            expiration: opt_expiration || null
        };
        try {
            localStorage.setItem(key, JSON.stringify(valueObj));
        } catch(e) {}
    },

    /**
     * @param {string} key
     * @return {*=}
     */
    get: function(key) {
        try {
            var rawItem = localStorage.getItem(key);
            var valueObj = rawItem ? JSON.parse(rawItem) : {};

            /*
             * If stored object is expired:
             * - remove it
             * - return undefined
             */
            if (valueObj.expiration && valueObj.expiration < (+new Date())) {
                html5Storage.remove(key);
                return undefined;
            }

            return valueObj.value;
        } catch(e) {
            return undefined;
        }
    },

    /**
     * @param {string} key
     */
    remove: function(key) {
        try {
            localStorage.removeItem(key);
        } catch(e) {}
    }
};

/**
 * Cookie storage object.
 * Inspired by http://docs.closure-library.googlecode.com/git/closure_goog_net_cookies.js.source.html
 */
var cookieStorage = {
    /**
     * @param {string} key
     * @param {*} value
     * @param {number=} opt_expiration In UTC time
     */
    set: function(key, value, opt_expiration) {
        function convertExpiration(exp) {
            return new Date(exp).toUTCString();
        }

        var expiration, expiresStr, oneWeekMs = 604800000;

        if (opt_expiration > 0) {
            expiration = convertExpiration(opt_expiration);
        } else if (opt_expiration === 0) {
            expiration = ';expires=' + (new Date(1970, 1 /*Feb*/, 1)).toUTCString();
        } else {
            expiration = (+new Date() + oneWeekMs);
        }

        document.cookie = key + '=' + JSON.stringify(value) + expiresStr;
    },

    /**
     * @param {string} key
     * @return {*=}
     */
    get: function(key) {
        function getParts() {
            return document.cookie.split(/\s*;\s*/);
        }
        var keyEq = key + '=',
            parts = getParts();
        for (var i = 0, part; part = parts[i]; ++i) {
            // startsWith
            if (part.lastIndexOf(keyEq, 0) === 0) {
                return part.substr(keyEq.length);
            }
            if (part === key) {
                return '';
            }
        }
        return undefined;
    },

    /**
     * @param {string} key
     */
    remove: function(key) {
        cookieStorage.set(key, '', 0);
    }
};

module.exports = canUseLocalStorage ? html5Storage : cookieStorage;

});

Livefyre.define('auth-delegates/user',['require','exports','module','event-emitter','inherits','auth-delegates/util/jsonp','auth-delegates/util/storage'],function (require, exports, module) {/**
 * @fileoverview Simplified user object that looks like a Backbone model, but with only 'CHANGE'
 * and 'CLEAR' events.
 * Note that including this file will setup a global `window.livefyre.user`, but won't override
 * an existing object. Use at own risk.
 * This should be assumed to be a global singleton.
 */

var EventEmitter = require('event-emitter'),
    inherits = require('inherits'),
    jsonp = require('auth-delegates/util/jsonp'),
    storage = require('auth-delegates/util/storage'),
    AUTH_COOKIE_KEY = 'fyre-auth';

/**
 * @param {Object} initialAttr
 * @constructor
 */
function LivefyreUser(initialAttr) {
    this._attributes = LivefyreUser.getDefaults();
    EventEmitter.call(this);
}
inherits(LivefyreUser, EventEmitter);

/** @return {Object.<string, *>} */
LivefyreUser.getDefaults = function() {
    return {
        'modMap': {},
        'keys': []
    };
};

/** @enum {string} */
LivefyreUser.EVENTS = {
    CHANGE: 'change',
    LOGOUT: 'logout',
    LOGIN: 'login',
    LOGIN_REQUESTED: 'loginRequested'
};

/**
 * @param {Object|string} keyOrObj
 * @param {*=} opt_value
 */
LivefyreUser.prototype.set = function(keyOrObj, opt_value) {
    var tempKey, k, val;
    // Assume object if not string
    if (typeof(keyOrObj) === 'string') {
        tempKey = keyOrObj;
        keyOrObj = {};
        keyOrObj[tempKey] = opt_value;
    }

    for (k in keyOrObj) {
        if (keyOrObj.hasOwnProperty(k)) {
            val = keyOrObj[k];
            this._attributes[k] = val;
            this.emit(LivefyreUser.EVENTS.CHANGE + ':' + k, val);
        }
    }
    this.emit(LivefyreUser.EVENTS.CHANGE, keyOrObj);
};

/**
 * Get a particular attribute
 * @param {string} key
 * @return {*}
 */
LivefyreUser.prototype.get = function(key) {
    return this._attributes[key];
};

/**
 * @param {string} key
 */
LivefyreUser.prototype.unset = function(key) {
    if (key in this._attributes) {
        delete this._attributes[key];
        var obj = {};
        obj[key] = void 0;
        this.emit(LivefyreUser.EVENTS.CHANGE + ':' + key, obj[key]);
    }
};

/**
 * Clear all attributes back to defaults.
 */
LivefyreUser.prototype.logout = LivefyreUser.prototype.reset = function() {
    this._attributes = {};
    this.set(LivefyreUser.getDefaults());
    storage.remove(AUTH_COOKIE_KEY);
    this.emit(LivefyreUser.EVENTS.LOGOUT);
};

/**
 * Simply sets the token. It is up to the authentication delegates to invoke the "remoteLogin"
 * by listening to "change:token".
 * @param {string) token
 */
LivefyreUser.prototype.login = function(token) {
    this.set('token', token);
    this.emit(LivefyreUser.EVENTS.LOGIN_REQUESTED, token);
};

/**
 * @param {Object} data
 * @param {string} articleId
 */
LivefyreUser.prototype.loadSession = function(data, articleId) {
    var profile = data['profile'],
        permissions = data['permissions'],
        authors = permissions['authors'],
        modKey = permissions['moderator_key'],
        storedModMap = data['mod_map'],
        tokenObj = data['token'],
        keys = [modKey],
        existingKeys = this.get('keys'),
        collectionId = data['collection_id'];

    profile['token'] = tokenObj['value'];

    for (var i = 0; i < authors.length; i++) {
        keys.push(authors[i]['key']);
    }
    this.set(profile);
    this.set('keys', existingKeys.concat(keys));

    if (storedModMap) {
        this.set('modMap', storedModMap);
    }

    var modMap = this.get('modMap');
    if (articleId && modKey) {
        modMap[articleId] = modKey;
    }
    if (collectionId && modKey) {
        modMap[collectionId] = modKey;
    }
    this.set('modMap', modMap);

    this.emit(LivefyreUser.EVENTS.LOGIN, profile);
};

/**
 * @param {string} collectionId
 * @return {boolean}
 */
LivefyreUser.prototype.isMod = function(articleId) {
    return articleId in this.get('modMap');
};

/**
 * @param {string} opts.articleId
 * @param {string} opts.siteId
 * @param {string=} opts.serverUrl
 * @param {function()=} opts.callback
 */
LivefyreUser.prototype.remoteLogin = function(opts) {
    // TODO(rrp): uri param helper
    var queryParams = 'articleId=' + encodeURIComponent(opts.articleId) + '&siteId=' + opts.siteId,
        url = (opts.serverUrl || 'http://livefyre.com') + '/api/v3.0/auth/?' + queryParams,
        self = this,
        token = this.get('token'),
        bpChannel = this.get('bpChannel');

    url += token ? '&token=' + encodeURIComponent(token) : '';
    url += bpChannel ? '&bp_channel=' + encodeURIComponent(bpChannel) : '';
    jsonp.req(url, function(err, resp) {
        if (err || (resp['data'] && !resp['data']['profile'])) {
            return;
        }
        var data = resp['data'],
            tokenObj = data['token'],
            ttl = (+new Date()) + tokenObj['ttl'];
        self.loadSession(data, opts.articleId);
        data['mod_map'] = self.get('modMap');
        storage.set(AUTH_COOKIE_KEY, data, ttl);
        opts.callback && opts.callback(data);
    });
};

/**
 * Set up global livefyre user object.
 */
window.Livefyre = window.Livefyre || {};
window.Livefyre.user = window.Livefyre.user || new LivefyreUser();
module.exports = window.Livefyre.user;

});

Livefyre.define('base64',['require','exports','module'],function (require, exports, module) {var base64 = {};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function InvalidCharacterError(message) {
  this.message = message;
}
InvalidCharacterError.prototype = new Error;
InvalidCharacterError.prototype.name = 'InvalidCharacterError';

// encoder
// [https://gist.github.com/999166] by [https://github.com/nignag]
base64.btoa = window.btoa ? function(input) { return window.btoa(input); } : function (input) {
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars, output = '';
    // if the next input index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    input.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = input.charCodeAt(idx += 3/4);
    if (charCode > 0xFF) {
      throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
    }
    block = block << 8 | charCode;
  }
  return output;
};

// decoder
// [https://gist.github.com/1020396] by [https://github.com/atk]
base64.atob = window.atob ? function(input) { return window.atob(input); } : function (input) {
  input = input.replace(/=+$/, '')
  if (input.length % 4 == 1) {
    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
  }
  for (
    // initialize result and counters
    var bc = 0, bs, buffer, idx = 0, output = '';
    // get next character
    buffer = input.charAt(idx++);
    // character found in table? initialize bit storage and add its ascii value;
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
      // and if not first of each 4 characters,
      // convert the first 8 bits to one ascii character
      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
  ) {
    // try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
  }
  return output;
};

module.exports = base64;

});

Livefyre.define('auth-delegates/util/bind',['require','exports','module'],function (require, exports, module) {module.exports = function(fn, selfObj, var_args) {
	if (!fn) {
		throw new Error();
	}

	if (arguments.length > 2) {
		var boundArgs = Array.prototype.slice.call(arguments, 2);
		return function() {
			// Prepend the bound arguments to the current arguments.
			var newArgs = Array.prototype.slice.call(arguments);
			Array.prototype.unshift.apply(newArgs, boundArgs);
			return fn.apply(selfObj, newArgs);
		};
	} else {
		return function() {
			return fn.apply(selfObj, arguments);
		};
	}
};

});

/*
 * JavaScript MD5 1.0.1
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 * 
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*jslint bitwise: true */
/*global unescape, define */

(function ($) {
    

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }

    /*
    * These functions implement the four basic operations the algorithm uses.
    */
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
    * Calculate the MD5 of an array of little-endian words, and a bit length.
    */
    function binl_md5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i],       7, -680876936);
            d = md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
            d = md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
            d = md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
            d = md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i],      20, -373897302);
            a = md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
            d = md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
            c = md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
            d = md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
            c = md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i +  5],  4, -378558);
            d = md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
            d = md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
            d = md5_hh(d, a, b, c, x[i],      11, -358537222);
            c = md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i],       6, -198630844);
            d = md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
            d = md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    }

    /*
    * Convert an array of little-endian words to a string
    */
    function binl2rstr(input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    }

    /*
    * Convert a raw string to an array of little-endian words
    * Characters >255 have their high-byte silently ignored.
    */
    function rstr2binl(input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    }

    /*
    * Calculate the MD5 of a raw string
    */
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
    }

    /*
    * Calculate the HMAC-MD5, of a key and some data (raw strings)
    */
    function rstr_hmac_md5(key, data) {
        var i,
            bkey = rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
            bkey = binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
    }

    /*
    * Convert a raw string to a hex string
    */
    function rstr2hex(input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    }

    /*
    * Encode a string as utf-8
    */
    function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
    }

    /*
    * Take string arguments and return either raw or hex encoded strings
    */
    function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
    }
    function hex_md5(s) {
        return rstr2hex(raw_md5(s));
    }
    function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
    }
    function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
    }

    function md5(string, key, raw) {
        if (!key) {
            if (!raw) {
                return hex_md5(string);
            }
            return raw_md5(string);
        }
        if (!raw) {
            return hex_hmac_md5(key, string);
        }
        return raw_hmac_md5(key, string);
    }

    if (typeof Livefyre.define === 'function' && Livefyre.define.amd) {
        Livefyre.define('md5',[],function () {
            return md5;
        });
    } else {
        $.md5 = md5;
    }
}(this));

Livefyre.define('auth-delegates/delegates/backplane',['require','exports','module','base64','auth-delegates/util/bind','auth-delegates/util/jsonp','md5','auth-delegates/util/storage','auth-delegates/user'],function (require, exports, module) {/**
 * @fileoverview Backplane auth delegate. Note the differences in implementation between 1.2 and 2.0
 * versions of Backplane.
 */
var base64 = require('base64'),
    bind = require('auth-delegates/util/bind'),
    jsonp = require('auth-delegates/util/jsonp'),
    md5 = require('md5'),
	storage = require('auth-delegates/util/storage'),
	user = require('auth-delegates/user'),
	AUTH_COOKIE_KEY = 'fyre-auth',
    BACKPLANE_CACHE_KEY = 'fyre-backplane-cache',
    BP_MSG_TYPES = {
        LOGIN: 'identity/login',
        LOGOUT: 'identity/logout'
    },
    USER_BP_KEY = 'bpChannel',
    VERSIONS = {
        v12: /1\.2\.[0-9]/,
        v20: /2\.0\.[0-9]/
    };

/**
 * Handles caching of Backplane + user information for easy session retrieval 
 */
var cache = {
    /**
     * Check the Backplane cache for a hit.
     * @param {Object} message Backplane message to add to cache.
     * @return {boolean} Whether we have a cache hit.
     */
    has: function(message) {
        var bpChannel = message['messageURL'] || user.get(USER_BP_KEY);
        var checksum = md5(JSON.stringify(message));
        var data = storage.get(BACKPLANE_CACHE_KEY);
        return data && bpChannel === data['channel'] && checksum === data['checksum'];
    },

    /**
     * Set the current message in the Backplane cache
     * @param {Object} message Backplane message to add to cache.
     */
    set: function(message) {
        var bpChannel = message['messageURL'] || user.get(USER_BP_KEY);
        var checksum = md5(JSON.stringify(message));
        storage.set(BACKPLANE_CACHE_KEY, {
            'channel': bpChannel,
            'checksum': checksum
        });
    },

    remove: function() {
        storage.remove(BACKPLANE_CACHE_KEY);
    }
};

/**
 * Get first matching message in reverse order. This is necesary because the user could have
 * logged in and out multiple times. We desire the latest message.
 * @param  {Array.<Object>} messages
 * @return {?Object}
 */
function extractLastMessage(messages) {
    var message, type, i = messages.length;

    while (i--) {
        message = messages[i];
        type = message['type'] || (message['message'] || {})['type'];
        if (type === BP_MSG_TYPES.LOGIN || type === BP_MSG_TYPES.LOGOUT) {
            return message;
        }
    }
    return null;
}


/**
 * Backplane 1.2 logic.
 * See: https://sites.google.com/site/backplanespec/documentation/backplane1-2
 * Also: http://developers.janrain.com/documentation/backplane-protocol/addtoyourwebsite/legacy-backplane-1x/
 * Upon page load fetch existing Backplane message from the bus.
 * This is the case in which the user is currently logged in, but
 * has navigated to a new page.
 * Uses the channel if set on the Livefyre.user model.
 * @param {Backplane} backplane
 * @param {Function()} handleMessage
 */
function backendv12(backplane, handleMessage) {
    var bpChannel = window.Backplane.getChannelID() || null;

    function handler(message) {
        user.set(USER_BP_KEY, bpChannel);
        handleMessage(message);
    }

    backplane.subscribe(handler);
    jsonp.req(bpChannel, function(err, data) {
        if (err) {
            return;
        }
        if (!data.length) {
            return;
        }
        var message = extractLastMessage(data);
        message && handler(message['message']);
    });
}

/**
 * Backplane 2.0 logic.
 * See: http://developers.janrain.com/documentation/backplane-protocol/addtoyourapplication/backplane-2-0/
 * @param {Backplane} backplane
 * @param {Function()} handleMessage
 */
function backendv20(backplane, handleMessage) {
    function handler(message) {
        user.set(USER_BP_KEY, message['messageURL']);
        handleMessage(message);
    }

    backplane.subscribe(handler);
    // Replay historic messages - this is how we will be notified of
    // identity events during a page refresh/redirect.
    var cachedMessages = backplane.getCachedMessages();
    if (cachedMessages.length) {
        // Priority is given to (more) recent messages
        var message = extractLastMessage(cachedMessages);
        if (message) {
            handler(message);
        }
    }
}

/**
 * @param {Backplane} backplane
 * @param {Function()} handleMessage
 */
function setSubscriptionByVersion(backplane, handleMessage) {
    var version = backplane.version;
    if (VERSIONS.v12.test(version)) {
        return backendv12(backplane, handleMessage);
    } else if (VERSIONS.v20.test(version)) {
        return backendv20(backplane, handleMessage);
    }
    throw 'Backplane delegate is only compatible with version 1.2 and 2.0 of Backplane';
}

/**
 * @param {string} articleId
 * @param {string} siteId
 * @param {string} serverUrl
 * @constructor
 */
function BackplaneDelegate(articleId, siteId, serverUrl) {
	if (!window.Backplane) {
		throw 'backplane instance must exist';
	}

    this.articleId = base64.btoa(articleId);
    this.siteId = siteId;
    this.serverUrl = serverUrl;

    // only call init once
    var bp = window.Backplane;
    var self = this;
    var initOnce = false;
    var callback = function() {
        self.currentBPChannel = bp.getChannelID() || null;
        setSubscriptionByVersion(bp, bind(self.handleBackplaneMessage, self));
        initOnce = true;
    };

    bp(function() {
        initOnce || callback();
    });
}

/**
 * Based on message type, takes a certain action.
 * @param {Object} message
 */
BackplaneDelegate.prototype.handleBackplaneMessage = function(message) {
    var messageType = message['type'];
    switch (messageType) {
        case BP_MSG_TYPES.LOGIN:
            if (cache.has(message)) {
                this.loadSession();
                break;
            }
            cache.set(message);
            user.remoteLogin({
                siteId: this.siteId,
                articleId: this.articleId,
                serverUrl: this.serverUrl
            });
            break;
        case BP_MSG_TYPES.LOGOUT:
            user.logout();
            break;
        default:
            throw 'This Backplane message type is not supported: ' + messageType;
    }
};

BackplaneDelegate.prototype.loadSession = function() {
    var cookieData = storage.get(AUTH_COOKIE_KEY) || {};
    if (cookieData['token']) {
        user.loadSession(cookieData);
    } else {
        storage.remove(AUTH_COOKIE_KEY);
    }
};

/**
 * As Backplane.resetCookieChannel spawns an async task to reset
 * the channel, poll and logout when the channel updates or after 5 seconds.
 */
BackplaneDelegate.prototype.logout = function() {
    var timeout, count = 0, self = this;
    function poll() {
        // A request to reset Backplane is handled asynchronoulsy via JSONP,
        // so we need to poll until the Backplane channel is reset, i.e. not
        // equal to the value we have stored on the class (and not falsy too).
        var bpChannelId = self.backplane.getChannelID();
        var isUpdated = bpChannelId && self.currentBPChannel !== bpChannelId;

        clearTimeout(timeout);

        if (isUpdated || count === 50) {
            cache.remove();
            self.currentBPChannel = self.backplane.getChannelID();
            return;
        }
        timeout = setTimeout(poll, 100);
    }

    poll();
	user.logout();
};

BackplaneDelegate.prototype.login = function() {};
BackplaneDelegate.prototype.viewProfile = function() {};
BackplaneDelegate.prototype.editProfile = function() {};

/**
 * Clean up any handlers, etc.
 */
BackplaneDelegate.prototype.destroy = function() {
    this.articleId = this.siteId = this.serverUrl = this.currentBPChannel = null;
};

module.exports = BackplaneDelegate;

});

Livefyre.define('auth-delegates/util/useragent',['require','exports','module'],function (require, exports, module) {/**
 * @filoverview Detect useragents. This should be used sparingly - in fact, most applications
 * that use authentication delegates should handle this themselves.
 */

var userAgent = navigator.userAgent.toLowerCase();
var isMobile = /(iphone|ipod|blackberry|android|palm|windows\s+ce)/.test(userAgent);
var isDesktop = /(windows|linux|os\s+[x9]|solaris|bsd)/.test(userAgent);
var isBot = /(spider|crawl|slurp|bot)/.test(userAgent);

module.exports = {
	isMobile: isMobile || !isBot || !isDesktop  // assume mobile if not bot or desktop
};

});

Livefyre.define('auth-delegates/delegates/lfsp',['require','exports','module','base64','../user','../util/useragent'],function (require, exports, module) {/** @fileoverview Livefyre Simple Profiles authentication delegate */

var base64 = require('base64'),
    user = require('../user'),
	useragent = require('../util/useragent');

/** @enum {string} */
var SP_EVENTS = {
    LOGIN_COMPLETE: 'auth_login_complete',
    LOGOUT_COMPLETE: 'auth_logout_complete',
    ENGAGE_AUTH_CLOSE: 'engage_auth_close'
};

/**
 * @param {string} articleId
 * @param {string} siteId
 * @param {Object=} opt_config Configuration options
 * @constructor
 */
function LfspDelegate(articleId, siteId, opt_config) {
    this.articleId = base64.btoa(articleId);
    this.siteId = siteId;

	var config = opt_config || {};

	var spObject = this.spObject = window.fyre.sp;
	this.engageApp = new spObject.app.Engage(config.engageOpts || {});
	this.profileApp = new spObject.app.Profile(config.profileOpts || {});

    spObject.on(SP_EVENTS.LOGIN_COMPLETE, function(data) {
        user.login(data['token']);
        user.remoteLogin({
            articleId: this.articleId,
            siteId: this.siteId,
            serverUrl: this.serverUrl
        });
    }, this);
    spObject.on(SP_EVENTS.LOGOUT_COMPLETE, function() {
        user.logout();
    }, this);
}

/**
 *
 */
LfspDelegate.prototype.login = function() {
    function success(data) {
        user.login(data['token']);
        this.spObject.off(SP_EVENTS.LOGIN_COMPLETE, success);
        this.spObject.off(SP_EVENTS.ENGAGE_AUTH_CLOSE, failure);
    }
    function failure() {
        this.spObject.off(SP_EVENTS.ENGAGE_AUTH_CLOSE, failure);
        this.spObject.off(SP_EVENTS.LOGIN_COMPLETE, success);
    }
    this.engageApp.signIn();
    this.spObject.on(SP_EVENTS.LOGIN_COMPLETE, success, this);
    this.spObject.on(SP_EVENTS.ENGAGE_AUTH_CLOSE, failure, this);
};

/**
 * @param {function()} callback
 */
LfspDelegate.prototype.loadSession = function(callback) {};

/**
 * @param {function()} callback
 */
LfspDelegate.prototype.logout = function(callback) {
	this.engageApp.signOut();
};

/**
 * It really seems like the lfsp profiles app should take care of most of this
 * stuff.
 * @param {Object} author
 */
LfspDelegate.prototype.viewProfile = function(author) {
    var id, profileUrl;
    
    if (author.isCuratedAuthor) {
	    profileUrl = author.profileUrl;
	    if (!profileUrl) {
	        return;
	    }
	    if (useragent.isMobile) {
	        location.href = profileUrl;
	        return;
	    }
	    window.open(author.profileUrl,'authWindow',
            'location=true;menubar=false;resizable=false;scrollbars=false');
        return;
    }
    if (author.id !== user.id) {
        id = author.id.split('@')[0];
    }
    this.profileApp.viewProfile(id);

};

/**
 * Launch edit profile from lfsp.
 */
LfspDelegate.prototype.editProfile = function() {
	this.profileApp.editProfile();
};

/**
 * Clean up any handlers, etc.
 */
LfspDelegate.prototype.destroy = function() {
    this.spObject.off(null, null, this);
    this.articleId =
        this.siteId =
        this.serverUrl =
        this.profileApp =
        this.engageApp = null;
};

module.exports = LfspDelegate;

});

Livefyre.define('auth-delegates/delegates/livefyre',['require','exports','module','base64','auth-delegates/util/bind','auth-delegates/util/jsonp','auth-delegates/util/storage','auth-delegates/user'],function (require, exports, module) {var base64 = require('base64'),
    bind = require('auth-delegates/util/bind'),
    jsonp = require('auth-delegates/util/jsonp'),
    storage = require('auth-delegates/util/storage'),
    user = require('auth-delegates/user'),
    userAgent = navigator.userAgent,
    IS_OPERA = userAgent.indexOf('Opera') > -1,
    AUTH_COOKIE_KEY = 'fyre-auth';

/**
 * @param {string} articleId
 * @param {string} siteId
 * @param {string} serverUrl
 * @constructor
 */
function LivefyreDelegate(articleId, siteId, serverUrl) {
    this.articleId = base64.btoa(articleId);
    this.siteId = siteId;
    this.serverUrl = serverUrl;
    user.on('loginRequested', bind(this.fetchAuthData, this));
}

/**
 * Fire login popup, and on success login the user.
 */
LivefyreDelegate.prototype.login = function() {
    this._popup();
};

LivefyreDelegate.prototype.fetchAuthData = function() {
    if (!user.get('token')) {
        user.remoteLogin({
            articleId: this.articleId,
            siteId: this.siteId,
            serverUrl: this.serverUrl
        });
    }
};

/**
 * mmmmcookies
 */
LivefyreDelegate.prototype.loadSession = function() {
    var cookieData = storage.get(AUTH_COOKIE_KEY) || {};
    if (cookieData['token']) {
        user.loadSession(cookieData);
    } else {
        storage.remove(AUTH_COOKIE_KEY);
    }
};

/**
 * @param {function()} callback
 * @private
 */
LivefyreDelegate.prototype._popup = function(callback) {
    var serverUrl = this.serverUrl,
        articleId = this.articleId,
        siteId = this.siteId,

        windowUrl = serverUrl + '/auth/popup/login/?articleId=' + articleId + '&siteId=' + siteId,
        popup = window.open(windowUrl, 'authWindow',
        'width=530;height=365;location=true;menubar=false;resizable=false;scrollbars=false'),

        timeout = setInterval(function() {
            testResult(callback, popup);
        }, 100);

    function isActive(popup) {
        if (!popup) {
            return false;
        }
        try {
            // Opera has a bug that changes popup.closed to undefined rather than true.
            return (popup.closed === false);
        } catch(e) {
            if (IS_OPERA) {
                return true;
            }
            throw e;
        }
    }

    function testResult(callback, popup) {
        if (!isActive(popup)) {
            clearInterval(timeout);
            user.remoteLogin({
                articleId: articleId,
                siteId: siteId,
                serverUrl: serverUrl
            });
            return;
        }
    }
};

/**
 * @param {function()} callback
 */
LivefyreDelegate.prototype.logout = function() {
    var url = this.serverUrl + '/auth/logout/ajax/?nocache=' + (new Date()).getTime();
    jsonp.req(url, function(err, data) {
        if (!err) {
            user.logout();
        }
    });
};

/**
 * @param {Object} author
 */
LivefyreDelegate.prototype.viewProfile = function(author) {
    window.open(author.profileUrl, '_blank');
};

LivefyreDelegate.prototype.editProfile = function() {
    window.open(this._serverUrl + '/profile/edit/info/', '_blank');
};

/**
 * Clean up any handlers, etc.
 */
LivefyreDelegate.prototype.destroy = function() {
    this.articleId = this.siteId = this.serverUrl = null;
    user.removeListener('loginRequested', bind(this.fetchAuthData, this));
};

module.exports = LivefyreDelegate;

});

Livefyre.define('auth-delegates/delegates/remote',['require','exports','module','auth-delegates/util/storage','auth-delegates/user'],function (require, exports, module) {/**
 * @fileoverview Remote auth delegate is the base for any custom implementations
 * of auth for Livefyre.
 */

var storage = require('auth-delegates/util/storage'),
    user = require('auth-delegates/user'),
    AUTH_COOKIE_KEY = 'fyre-auth';

/**
 * @constructor
 */
function RemoteAuthDelegate() {}

RemoteAuthDelegate.prototype.loadSession = function() {
    var cookieData = storage.get(AUTH_COOKIE_KEY) || {};
    if (cookieData['token']) {
        user.loadSession(cookieData);
    } else {
        storage.remove(AUTH_COOKIE_KEY);
    }
};

RemoteAuthDelegate.prototype.logout = function() {
    user.logout();
};

// To be implemented by usef
RemoteAuthDelegate.prototype.login = function() {};
RemoteAuthDelegate.prototype.viewProfile = function() {};
RemoteAuthDelegate.prototype.editProfile = function() {};

/**
 * Clean up any handlers, etc.
 */
RemoteAuthDelegate.prototype.destroy = function() {};

module.exports = RemoteAuthDelegate;

});

Livefyre.define('auth-delegates/main',['require','exports','module','auth-delegates/user','auth-delegates/delegates/backplane','auth-delegates/delegates/lfsp','auth-delegates/delegates/livefyre','auth-delegates/delegates/remote'],function (require, exports, module) {require('auth-delegates/user');
require('auth-delegates/delegates/backplane');
require('auth-delegates/delegates/lfsp');
require('auth-delegates/delegates/livefyre');
require('auth-delegates/delegates/remote');

});

Livefyre.define('auth-delegates', ['auth-delegates/main'], function (main) { return main; });

//# sourceMappingURL=auth-delegates.min.js.map