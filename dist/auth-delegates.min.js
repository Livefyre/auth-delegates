
var Livefyre;(function () { if (!Livefyre || !Livefyre.requirejs) {
if (!Livefyre) { Livefyre = {}; } else { require = Livefyre; }
/**
 * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

Livefyre.requirejs = requirejs;Livefyre.require = require;Livefyre.define = define;
}
}());
Livefyre.define("almond", function(){});

Livefyre.define('event-emitter',[],function() {

    var slice = Array.prototype.slice;

    /**
     * Defines the base class for all event emitting objects to extend.
     * @exports streamhub-sdk/event-emitter
     * @constructor
     */
    var EventEmitter = function() {
        this._listeners = {};
    };


    EventEmitter.listenerCount = function (emitter, eventName) {
        var listeners = emitter._listeners[eventName];
        if ( ! listeners) {
            return 0;
        }
        return listeners.length;
    };


    /**
     * Binds a listener function to an event name.
     * @param name {string} The event name to bind to.
     * @param fn {function} The callback function to call whenever the event is emitted.
     * @returns {EventEmitter} Returns 'this' for chaining
     */
    EventEmitter.prototype.on = function(name, fn) {
        this._listeners[name] = this._listeners[name] || [];
        this._listeners[name].push(fn);
        return this;
    };
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;


    EventEmitter.prototype.once = function (name, fn) {
        function doAndRemoveListener () {
            this.removeListener(name, doAndRemoveListener);
            fn.apply(this, arguments);
        }
        // Store original listener
        doAndRemoveListener.listener = fn;
        return this.on(name, doAndRemoveListener);
    };


    /**
     * Removes a bound listener from the named event.
     * @param name {string} The name of the event to remove this listener from.
     * @param fn {function} The original callback function to remove.
     */
    EventEmitter.prototype.removeListener = function(name, fn) {
        if (fn && this._listeners[name]) {
            this._listeners[name].splice(this._listeners[name].indexOf(fn), 1);
        }
    };

    /**
     * Emits an event from the object this is called on. Iterates through bound
     * listeners and passes through the arguments emit was called with.
     * @param name {string} The name of the event to emit.
     * @param {...Object} Optional arguments to pass to each listener's callback.
     */
    EventEmitter.prototype.emit = function(name) {
        var listeners = this._listeners[name] || [],
            args = slice.call(arguments, 1),
            err;

        // Copy listeners in case executing them mutates the array
        // e.g. .once() listeners remove themselves
        if (listeners.length) {
            listeners = listeners.slice();
        }
        
        // Throw on error event if there are no listeners
        if (name === 'error' && ! listeners.length) {
            err = args[0];
            if (err instanceof Error) {
                throw err;
            } else {
                throw TypeError('Uncaught, unspecified "error" event');
            }
        }

        for (var i=0, numListeners=listeners.length; i < numListeners; i++) {
            try {
                listeners[i].apply(this, args); 
            } catch(err) {
                this.emit('error', err);
            }
        }
    };

    return EventEmitter;
});

Livefyre.define('inherits',[], function () {


    /**
     * sub should prototypally inherit from base
     * @param sub {function} Subclass constructor
     * @param base {function} Base class constructor
     */
    function inherits (sub, base) {
        var Fn = function(){};
        Fn.prototype = base.prototype;
        sub.prototype = new Fn();
        sub.prototype.constructor = sub;
    }


    /**
     * sub should parasitically inherit from base
     * that is, we should pluck values from base.prototype onto sub.prototype
     */
    inherits.parasitically = function (sub, base) {
        var baseKeys = inherits.keys(base.prototype),
            baseKeysLength = baseKeys.length,
            methodName;
        for (var i=0; i < baseKeysLength; i++) {
            methodName = baseKeys[i];
            if ( ! sub.prototype[methodName]) {
                sub.prototype[methodName] = base.prototype[methodName];
            }
        }
    };


    /**
     * Object.keys shim
     */
    inherits.keys = Object.keys || (function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{toString:null}.propertyIsEnumerable("toString"),
            DontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            DontEnumsLength = DontEnums.length;

        return function (o) {
            if (typeof o != "object" && typeof o != "function" || o === null)
                throw new TypeError("Object.keys called on a non-object");

            var result = [];
            for (var name in o) {
                if (hasOwnProperty.call(o, name))
                    result.push(name);
            }

            if (hasDontEnumBug) {
                for (var i = 0; i < DontEnumsLength; i++) {
                    if (hasOwnProperty.call(o, DontEnums[i]))
                        result.push(DontEnums[i]);
                }
            }

            return result;
        };
    })();

    return inherits;
});
Livefyre.define('auth-delegates/util/jsonp',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview Very small jsonp implementation.
 */

function req(url, callback) {
    var rand = '_lfcallback_' + (+new Date()),
        script = document.createElement('script'),
        sep = url.indexOf('?') > 0 ? '&' : '?';

    function clean() {
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
        delete window[rand];
    }

    window[rand] = function(data) {
        clean();
        callback(null, data);
    }

    script.type = 'text/javascript';
    script.async = true;

    script.onerror = function() {
        clean();
        callback('error');
    };

    script.src = url + sep + 'callback=' + rand;
    document.getElementsByTagName('head')[0].appendChild(script);
}

module.exports = {
    req: req
};

});

Livefyre.define('auth-delegates/util/storage',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview Storage helpers: if window.localStroage is unavailable, then defaults to cookie
 * based storage. Automatically handles expiration and JSON serialization for both types of storage.
 */

var STORAGE_AVAILABLE_KEY = '__lfstorage__',
    canUseLocalStorage = (function() {
        try {
            // Weird cases where accessing localStorage global will throw an error.
            var storage = localStorage || null;
            // setItem will throw an exception if we cannot access WebStorage (e.g.,
            // Safari in private mode).
            storage.setItem(STORAGE_AVAILABLE_KEY, '1');
            storage.removeItem(STORAGE_AVAILABLE_KEY);
            return true;
        } catch (e) {
            return false;
        }
    })();

/**
 * LocalStorage storage object.
 * Attempts to rectify the many ways that browsers can interpret the localStorage object with heavy
 * use of try-catch blocks.
 */
var html5Storage = {
    /**
     * @param {string} key
     * @param {*} value
     * @param {number=} opt_expiration In UTC time
     */
    set: function(key, value, opt_expiration) {
        var valueObj = {
            value: value,
            expiration: opt_expiration || null
        };
        try {
            localStorage.setItem(key, JSON.stringify(valueObj));
        } catch(e) {}
    },

    /**
     * @param {string} key
     * @return {*=}
     */
    get: function(key) {
        try {
            var rawItem = localStorage.getItem(key);
            var valueObj = rawItem ? JSON.parse(rawItem) : {};

            /*
             * If stored object is expired:
             * - remove it
             * - return undefined
             */
            if (valueObj.expiration && valueObj.expiration < (+new Date())) {
                html5Storage.remove(key);
                return undefined;
            }

            return valueObj.value;
        } catch(e) {
            return undefined;
        }
    },

    /**
     * @param {string} key
     */
    remove: function(key) {
        try {
            localStorage.removeItem(key);
        } catch(e) {}
    }
};

/**
 * Cookie storage object.
 * Inspired by http://docs.closure-library.googlecode.com/git/closure_goog_net_cookies.js.source.html
 */
var cookieStorage = {
    /**
     * @param {string} key
     * @param {*} value
     * @param {number=} opt_expiration In UTC time
     */
    set: function(key, value, opt_expiration) {
        function convertExpiration(exp) {
            return new Date(exp).toUTCString();
        }

        var expiration, expiresStr, oneWeekMs = 604800000;

        if (opt_expiration > 0) {
            expiration = convertExpiration(opt_expiration);
        } else if (opt_expiration === 0) {
            expiration = ';expires=' + (new Date(1970, 1 /*Feb*/, 1)).toUTCString();
        } else {
            expiration = (+new Date() + oneWeekMs);
        }

        document.cookie = key + '=' + JSON.stringify(value) + expiresStr;
    },

    /**
     * @param {string} key
     * @return {*=}
     */
    get: function(key) {
        function getParts() {
            return document.cookie.split(/\s*;\s*/)
        }
        var keyEq = key + '=',
            parts = getParts();
        for (var i = 0, part; part = parts[i]; ++i) {
            // startsWith
            if (part.lastIndexOf(keyEq, 0) === 0) {
                return part.substr(keyEq.length);
            }
            if (part == key) {
                return '';
            }
        }
        return undefined;
    },

    /**
     * @param {string} key
     */
    remove: function(key) {
        cookieStorage.set(key, '', 0);
    }
};

module.exports = canUseLocalStorage ? html5Storage : cookieStorage;

});

Livefyre.define('auth-delegates/user',['require','exports','module','event-emitter','inherits','auth-delegates/util/jsonp','auth-delegates/util/storage'],function (require, exports, module) {/**
 * @fileoverview Simplified user object that looks like a Backbone model, but with only 'CHANGE'
 * and 'CLEAR' events.
 * Note that including this file will setup a global `window.livefyre.user`, but won't override
 * an existing object. Use at own risk.
 * This should be assumed to be a global singleton.
 */

var EventEmitter = require('event-emitter'),
    inherits = require('inherits'),
    jsonp = require('auth-delegates/util/jsonp'),
    storage = require('auth-delegates/util/storage'),
    AUTH_COOKIE_KEY = 'fyre-auth';

/**
 * @param {Object} initialAttr
 * @constructor
 */
function LivefyreUser(initialAttr) {
    this._attributes = LivefyreUser.getDefaults();
    EventEmitter.call(this);
}
inherits(LivefyreUser, EventEmitter);

/** @return {Object.<string, *>} */
LivefyreUser.getDefaults = function() {
    return {
        'modMap': {},
        'keys': []
    };
};

/** @enum {string} */
LivefyreUser.EVENTS = {
    CHANGE: 'change',
    LOGOUT: 'logout',
    LOGIN: 'login',
    LOGIN_REQUESTED: 'loginRequested'
};

/**
 * @param {Object|string} keyOrObj
 * @param {*=} opt_value
 */
LivefyreUser.prototype.set = function(keyOrObj, opt_value) {
    var tempKey, k, val;
    // Assume object if not string
    if (typeof(keyOrObj) === 'string') {
        tempKey = keyOrObj;
        keyOrObj = {};
        keyOrObj[tempKey] = opt_value;
    }

    for (k in keyOrObj) {
        val = keyOrObj[k];
        this._attributes[k] = val;
        this.emit(LivefyreUser.EVENTS.CHANGE + ':' + k, val);
    }
    this.emit(LivefyreUser.EVENTS.CHANGE, keyOrObj);
};

/**
 * Get a particular attribute
 * @param {string} key
 * @return {*}
 */
LivefyreUser.prototype.get = function(key) {
    return this._attributes[key];
};

/**
 * @param {string} key
 */
LivefyreUser.prototype.unset = function(key) {
    if (key in this._attributes) {
        delete this._attributes[key];
        var obj = {};
        obj[key] = void 0;
        this.emit(LivefyreUser.EVENTS.CHANGE + ':' + key, obj[key]);
    }
};

/** 
 * Clear all attributes back to defaults.
 */
LivefyreUser.prototype.logout = LivefyreUser.prototype.reset = function() {
    this._attributes = {};
    this.set(LivefyreUser.getDefaults());
    storage.remove(AUTH_COOKIE_KEY);
    this.emit(LivefyreUser.EVENTS.LOGOUT);
};

/**
 * Simply sets the token. It is up to the authentication delegates to invoke the "remoteLogin"
 * by listening to "change:token".
 * @param {string) token
 */
LivefyreUser.prototype.login = function(token) {
    this.set('token', token);
    this.emit(LivefyreUser.EVENTS.LOGIN_REQUESTED, token);
};

/**
 * @param {Object} data
 * @param {sting} articleId
 */
LivefyreUser.prototype.loadSession = function(data, articleId) {
    var profile = data['profile'],
        permissions = data['permissions'],
        authors = permissions['authors'],
        modKey = permissions['moderator_key'],
        tokenObj = data['token'],
        ttl = (+new Date()) + tokenObj['ttl'],
        keys = [modKey],
        existingKeys = this.get('keys');

    for (var i = 0; i < authors.length; i++) {
        keys.push(authors[i]['key']);
    }
    this.set(profile);
    this.set('keys', existingKeys.concat(keys));

    if (modKey) {
        var modMap = this.get('modMap');
        modMap[articleId] = modKey;
        this.set('modMap', modMap);
    }

    this.emit(LivefyreUser.EVENTS.LOGIN, profile);
};

/**
 * @param {string} collectionId
 * @return {boolean}
 */
LivefyreUser.prototype.isMod = function(articleId) {
    return articleId in this.get('modMap');
};

/**
 * @param {string} articleId
 * @param {string} siteId
 * @param {string=} opt_serverUrl
 * @param {function()=} opt_callback
 */
LivefyreUser.prototype.remoteLogin = function(articleId, siteId, opt_serverUrl, opt_callback) {
    var queryParams = 'articleId=' + articleId + '&siteId=' + siteId,
        url = (opt_serverUrl || 'http://livefyre.com') + '/api/v3.0/auth/?' + queryParams,
        self = this,
        token = this.get('token');

    url += token ? '&token=' + token : '';
    jsonp.req(url, function(err, resp) {
        if (err || (resp['data'] && !resp['data']['profile'])) {
            return;
        }
        var data = resp['data'],
            tokenObj = data['token'],
            ttl = (+new Date()) + tokenObj['ttl'];
        self.loadSession(data, articleId);
        storage.set(AUTH_COOKIE_KEY, data, ttl);
        opt_callback && opt_callback(data);
    });
};

/**
 * Set up global livefyre user object.
 */
window.Livefyre = window.Livefyre || {};
window.Livefyre.user = window.Livefyre.user || new LivefyreUser();
module.exports = window.Livefyre.user;

});

Livefyre.define('auth-delegates/util/useragent',['require','exports','module'],function (require, exports, module) {/**
 * @filoverview Detect useragents. This should be used sparingly - in fact, most applications
 * that use authentication delegates should handle this themselves.
 */

var userAgent = navigator.userAgent.toLowerCase();
var isMobile = /(iphone|ipod|blackberry|android|palm|windows\s+ce)/.test(userAgent);
var isDesktop = /(windows|linux|os\s+[x9]|solaris|bsd)/.test(userAgent);
var isBot = /(spider|crawl|slurp|bot)/.test(userAgent);

module.exports = {
	isMobile: isMobile || !isBot || !isDesktop  // assume mobile if not bot or desktop
};

});

Livefyre.define('auth-delegates/delegates/lfsp',['require','exports','module','../user','../util/useragent'],function (require, exports, module) {/** @fileoverview Livefyre Simple Profiles authentication delegate */

var user = require('../user'),
	useragent = require('../util/useragent');

/** @enum {string} */
var SP_EVENTS = {
    LOGIN_COMPLETE: 'auth_login_complete',
    LOGOUT_COMPLETE: 'auth_logout_complete',
    ENGAGE_AUTH_CLOSE: 'engage_auth_close'
};

/**
 * @param {string} articleId
 * @param {string} siteId
 * @param {Object=} opt_config Configuration options
 * @constructor
 */
function LfspDelegate(articleId, siteId, opt_config) {
    this.articleId = articleId;
    this.siteId = siteId;

	var config = opt_config || {};

	var spObject = this.spObject = window.fyre.sp;
	this.engageApp = new spObject.app.Engage(config.engageOpts || {});
	this.profileApp = new spObject.app.Profile(config.profileOpts || {});

    spObject.on(SP_EVENTS.LOGIN_COMPLETE, function(data) {
        user.login(data['token']);
        user.remoteLogin(this.articleId, this.siteId, this.serverUrl);
    }, this);
    spObject.on(SP_EVENTS.LOGOUT_COMPLETE, function() {
        user.logout();
    }, this);
}

/**
 *
 */
LfspDelegate.prototype.login = function() {
    function success(data) {
        user.login(data['token']);
        this.spObject.off(SP_EVENTS.LOGIN_COMPLETE, success);
        this.spObject.off(SP_EVENTS.ENGAGE_AUTH_CLOSE, failure);
    }
    function failure() {
        this.spObject.off(SP_EVENTS.ENGAGE_AUTH_CLOSE, failure);
        this.spObject.off(SP_EVENTS.LOGIN_COMPLETE, success);
    }
    this.engageApp.signIn();
    this.spObject.on(SP_EVENTS.LOGIN_COMPLETE, success, this);
    this.spObject.on(SP_EVENTS.ENGAGE_AUTH_CLOSE, failure, this);
};

/**
 * @param {function()} callback
 */
LfspDelegate.prototype.loadSession = function(callback) {};

/**
 * @param {function()} callback
 */
LfspDelegate.prototype.logout = function(callback) {
	this.engageApp.signOut();
};

/**
 * It really seems like the lfsp profiles app should take care of most of this
 * stuff.
 * @param {Object} author
 */
LfspDelegate.prototype.viewProfile = function(author) {
    var id, profileUrl;
    
    if (author.isCuratedAuthor) {
	    profileUrl = author.profileUrl;
	    if (!profileUrl) {
	        return;
	    }
	    if (useragent.isMobile) {
	        location.href = profileUrl;
	        return;
	    }
	    window.open(author.profileUrl,'authWindow',
	    	'location=true;menubar=false;resizable=false;scrollbars=false');
        return;
    }
    if (author.id !== user.id) {
        id = author.id.split('@')[0];
    }
    this.profileApp.viewProfile(id);

};

/**
 * Launch edit profile from lfsp.
 */
LfspDelegate.prototype.editProfile = function() {
	this.profileApp.editProfile();
};

/**
 * Clean
 */
LfspDelegate.prototype.destroy = function() {
    this.spObject.off(null, null, this);
    this.articleId =
        this.siteId =
        this.serverUrl =
        this.profileApp =
        this.engageApp = null;
};

module.exports = LfspDelegate;

});

Livefyre.define('auth-delegates/util/bind',['require','exports','module'],function (require, exports, module) {module.exports = function(fn, selfObj, var_args) {
	if (!fn) {
		throw new Error();
	}

	if (arguments.length > 2) {
		var boundArgs = Array.prototype.slice.call(arguments, 2);
		return function() {
			// Prepend the bound arguments to the current arguments.
			var newArgs = Array.prototype.slice.call(arguments);
			Array.prototype.unshift.apply(newArgs, boundArgs);
			return fn.apply(selfObj, newArgs);
		};
	} else {
		return function() {
			return fn.apply(selfObj, arguments);
		};
	}
};

});

Livefyre.define('auth-delegates/delegates/livefyre',['require','exports','module','auth-delegates/util/bind','auth-delegates/util/jsonp','auth-delegates/util/storage','auth-delegates/user'],function (require, exports, module) {var bind = require('auth-delegates/util/bind'),
    jsonp = require('auth-delegates/util/jsonp'),
    storage = require('auth-delegates/util/storage'),
    user = require('auth-delegates/user'),
    userAgent = navigator.userAgent,
    IS_OPERA = userAgent.indexOf('Opera') > -1,
    AUTH_COOKIE_KEY = 'fyre-auth';

/**
 * @param {string} articleId
 * @param {string} siteId
 * @param {string} serverUrl
 * @constructor
 */
function LivefyreDelegate(articleId, siteId, serverUrl) {
    this.articleId = articleId;
    this.siteId = siteId;
    this.serverUrl = serverUrl;
    user.on('loginRequested', bind(this.fetchAuthData, this));
}

/**
 * Fire login popup, and on success login the user.
 */
LivefyreDelegate.prototype.login = function() {
    this._popup();
};

LivefyreDelegate.prototype.fetchAuthData = function() {
    if (!user.get('token')) {
        user.remoteLogin(this.articleId, this.siteId, this.serverUrl);
    }
};

/**
 * mmmmcookies
 */
LivefyreDelegate.prototype.loadSession = function() {
    var cookieData = storage.get(AUTH_COOKIE_KEY) || {};
    if (cookieData['token']) {
        user.loadSession(cookieData);
    } else {
        storage.remove(AUTH_COOKIE_KEY);
    }
};

/**
 * @param {function()} callback
 * @private
 */
LivefyreDelegate.prototype._popup = function(callback) {
    var serverUrl = this.serverUrl,
        articleId = this.articleId,
        siteId = this.siteId,

        windowUrl = serverUrl + '/auth/popup/login/?articleId=' + articleId + '&siteId=' + siteId,
        popup = window.open(windowUrl, 'authWindow',
        'width=530;height=365;location=true;menubar=false;resizable=false;scrollbars=false'),

        timeout = setInterval(function() {
            testResult(callback, popup);
        }, 100);

    function isActive(popup) {
        if (!popup) {
            return false;
        }
        try {
            // Opera has a bug that changes popup.closed to undefined rather than true.
            return (popup.closed === false);
        } catch(e) {
            if (IS_OPERA) {
                return true;
            }
            throw e;
        }
    }

    function testResult(callback, popup) {
        if (!isActive(popup)) {
            clearInterval(timeout);
            user.remoteLogin(articleId, siteId, serverUrl);
            return;
        }
    }
};

/**
 * @param {function()} callback
 */
LivefyreDelegate.prototype.logout = function() {
    var url = this.serverUrl + '/auth/logout/ajax/?nocache=' + (new Date()).getTime();
    jsonp.req(url, function(err, data) {
        if (!err) {
            user.logout();
        }
    });
};

LivefyreDelegate.prototype.viewProfile = function() {
    window.open(this._serverUrl + '/profile/', '_blank');
};

LivefyreDelegate.prototype.editProfile = function() {
    window.open(this._serverUrl + '/profile/edit/info/', '_blank');
};

LivefyreDelegate.prototype.destroy = function() {
    this.articleId = this.siteId = this.serverUrl = null;
    user.removeListener('loginRequested', bind(this.fetchAuthData, this));
};

module.exports = LivefyreDelegate;

});

Livefyre.define('auth-delegates/main',['require','exports','module','auth-delegates/user','auth-delegates/delegates/lfsp','auth-delegates/delegates/livefyre'],function (require, exports, module) {require('auth-delegates/user');
require('auth-delegates/delegates/lfsp');
require('auth-delegates/delegates/livefyre');

});

Livefyre.define('auth-delegates', ['auth-delegates/main'], function (main) { return main; });

//# sourceMappingURL=auth-delegates.min.js.map